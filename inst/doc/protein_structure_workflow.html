<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Jan-Philipp Quast, Patrick Stalder" />

<meta name="date" content="2023-01-20" />

<title>Protein Structure Analysis Workflow</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Protein Structure Analysis Workflow</h1>
<h4 class="author">Jan-Philipp Quast, Patrick Stalder</h4>
<h4 class="date">2023-01-20</h4>



<style>
body {
text-align: justify}
</style>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>This vignette will take you through all important tools
<strong>protti</strong> provides for structural data analysis. These
include functions that allow you to fetch information about protein
structures both on an experimental as well as structural level.
Additionally, structure contact maps can be created from distances
between atoms. Lastly, B-factors* of structures can be manipulated to
contain custom values. This gives you the ability to colour regions on
structures as well as to apply continuous values associated with each
amino acid as a colour gradient using biomolecular visualisation
software such as PyMOL or ChimeraX or the R package
<code>r3dmol</code>.</p>
<p><em>*B-factors or temperature factors are used in structural biology
to describe the atomic displacement in the structure. In low resolution
structures they might correspond to the flexibility of regions, while in
high resolution structures they should not be used to infer information
regarding flexibility.</em></p>
<p>In structural proteomics, protein structural changes can be
determined using methods such as limited proteolysis coupled to mass
spectrometry (<a href="https://www.nature.com/articles/nbt.2999">LiP-MS</a>),
cross-linking mass spectrometry (<a href="https://pubmed.ncbi.nlm.nih.gov/29160693/">XL-MS</a>) and
hydrogen/deuterium exchange mass spectrometry (<a href="https://pubs.rsc.org/en/content/articlelanding/2011/CS/C0CS00113A">HDX-MS</a>).
In case of LiP-MS, structural changes can be identified with peptide or
precursor* centric proteomics in the form of peptide or precursor fold
changes. Relating this information to positions within the 3D space of a
protein can be very helpful to infer potential functional roles of those
structural changes. If structural changes occur close to the active site
of an enzyme, kinetics might be affected, if they occur at a
protein-protein binding interface, the corresponding protein complex
might have dissociated or assembled.</p>
<p><em>*Peptide precursors are the different charge states of a peptide
(+/- modifications) and the actual molecular unit that is detected in
the mass spectrometer.</em></p>
<div id="structural-data" class="section level2">
<h2>Structural data</h2>
<p>The world wide Protein Data Bank (wwPDB) manages and archives
information about the 3D structure of proteins. Its information can be
accessed through several websites such as the Research Collaboratory for
Structural Bioinformatics (<a href="https://www.rcsb.org">RCSB</a>).</p>
<p>When working with structure files it is important to keep a few
things in mind such that mistakes can be avoided. One aspect to consider
is that protein structure files come in two mainly used formats, namely
the PDB file format (.pdb) and the mmCIF file format (.cif). The PDB
file format is the legacy file format of the Protein Data Bank, which
has been replaced with the newer mmCIF file format that stores data on
biological macromolecules. All structures available in the Protein Data
Bank are available as a mmCIF file, while not all are available as a PDB
file. Mainly large protein complexes only contain mmCIF files.</p>
<p>The way both files store data and relate to each other can be quite
complex. There are several resources explaining their <a href="https://mmcif.wwpdb.org/docs/pdb_to_pdbx_correspondences.html">relation</a>
and their <a href="https://mmcif.wwpdb.org/docs/pubs/AUTHOR_ch4o5.pdf">content</a>.
The most important thing to know about these files for you as a user of
<strong>protti</strong> is the fact that there are different naming
conventions for elements of the structure.</p>
<p>PDB files solely use the naming provided by the author of the
structure in order to match the identification used in the publication
that describes the structure. Columns containing author information
start with the prefix “<code>auth_</code>”. This includes the naming of
chains (<code>asym_id</code>), atom IDs (<code>atom_id</code>) and
residue IDs (<code>seq_id</code>).</p>
<p>mmCIF files use both the naming provided by the author and a naming
following the standardised conventions for mmCIF files. Columns
containing standardised information start with the prefix
“<code>label_</code>”.</p>
<p><em><strong>Additional information:</strong> The differences between
author provided and standardised labeling may vary a lot depending on
the structure and can be quite confusing. An example taken from the <a href="https://mmcif.wwpdb.org/docs/pubs/AUTHOR_ch4o5.pdf">documentation</a>
of mmCIF files describes the relationship between author provided and
standardised residue IDs as follows: The <code>label_seq_id</code>
(standardised residue ID) column is required to be a sequential list of
positive integers, while the <code>auth_seq_id</code> (author residue
ID) is not necessarily a number and the values do not have to be
positive. The author may assign values to <code>auth_seq_id</code> in
any desired way. For instance, the values may be used to relate this
structure to a numbering scheme in a homologous structure, including
sequence gaps or insertion codes. Alternatively, a scheme may be used
for a truncated polymer that maintains the numbering scheme of the full
length polymer. In all cases, the scheme used here must match the scheme
used in the publication that describes the structure.</em></p>
<p>For the use of the functions in <strong>protti</strong> it is
important to know that these two different conventions exist.
<strong>All functions usually take the author provided information as
inputs.</strong> This has the reason that even though the PDB file
format is a legacy format, many people still mainly use this format.
With the <code>find_peptide_in_structure()</code> function we provide a
convenient way for you to find both the standardised and the author
provided residue numberings for a peptide, protein region or amino acid,
returning their UniProt start and end position. In addition, we return
the full stretch of residue annotations for the author provided
information in the column <code>auth_seq_id</code> since they are not
necessarily consecutive as previously mentioned.</p>
</div>
</div>
<div id="getting-started" class="section level1">
<h1>Getting started</h1>
<p>Before starting the structural analysis of your data you need to load
<strong>protti</strong> and additional packages used for the analysis.
As described on the <a href="https://jpquast.github.io/protti/index.html">main page</a> of
<strong>protti</strong>, the <a href="https://www.tidyverse.org">tidyverse</a> package collection works
well together with the rest of the package, by design. You can load
packages with the <code>library()</code> function.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load packages</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(protti)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(magrittr)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(stringr)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyr)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span></code></pre></div>
<p>We will demonstrate the use of <strong>protti</strong>’s structure
analysis functions based on a data set of peptides that were
significantly changing in a LiP-MS experiment and thus point towards a
structural change in the protein.</p>
<p>The functions used in this analysis can also be used in a different
context than a structural proteomics experiment. Instead of peptides you
can investigate the positioning of individual amino acids, or whole
domains within a protein.</p>
<div id="loading-data" class="section level2">
<h2>Loading data</h2>
<p>For this vignette we use a subset of two proteins from separate
LiP-MS experiments that contain peptides significantly changing in
abundance due to a structural change. We combined these two proteins
into one data set to showcase that multiple proteins and structures can
be analysed at once. The data was obtained from the paper “Dynamic 3D
proteomes reveal protein functional alterations at high resolution in
situ” (<a href="https://doi.org/10.1016/j.cell.2020.12.021">Cappelletti
2021</a>). Both experiments were conducted on purified <em>E. coli</em>
proteins spiked into <em>E. coli</em> lysates. The first protein is
phosphoglycerate kinase 1 (pgk) which was treated with 25 mM
3-phosphoglyceric acid (3PG). The second protein is
phosphoenolpyruvate-protein phosphotransferase (ptsI) which was treated
with 25 mM fructose 1,6-bisphosphatase (FBP).</p>
<p>Based on structural changes observed in these proteins the authors
conclude that FBP binds to the active site of ptsI and acts as a
competitive inhibitor, which is confirmed by an activity assay. The
structural change in pgk caused by 3PG is likely representative of
substrate occupancy and correlates with metabolic flux changes.</p>
<p>The example data is included in <strong>protti</strong> and you can
easily use it by calling the <code>data()</code> function. This will
load the data into your R session.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>utils<span class="sc">::</span><span class="fu">data</span>(<span class="st">&quot;ptsi_pgk&quot;</span>)</span></code></pre></div>
<p>If you want to read your own data into R, we suggest using the
<code>read_protti()</code> function. This function is a wrapper around
the fast <code>fread()</code> function from the <a href="https://rdatatable.gitlab.io/data.table/"><code>data.table</code></a>
package and the <code>clean_names()</code> function from the <a href="https://sfirke.github.io/janitor/"><code>janitor</code></a>
package. This will allow you to not only load your data into R very
fast, but also to clean up the column names into lower snake case. This
will make it easier to remember them and to use them in your data
analysis. Usually you would perform the following analysis after the
analyses described in either the <a href="https://jpquast.github.io/protti/articles/data_analysis_single_dose_treatment_workflow.html">vignette
for single dose treatments</a> or the <a href="https://jpquast.github.io/protti/articles/data_analysis_dose_response_workflow.html">vignette
for dose response data</a>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load data</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>your_data <span class="ot">&lt;-</span> <span class="fu">read_protti</span>(<span class="st">&quot;your_differential_abundance_data.csv&quot;</span>)</span></code></pre></div>
</div>
<div id="preparing-data" class="section level2">
<h2>Preparing data</h2>
<p>First we need to annotate the data with information required for
structural data analysis. To find peptides in a protein structure we
need to know their positions in the protein first. For this we can use
the <strong>protti</strong> function <code>find_peptide()</code>. This
function searches for the peptide within the protein sequence, which we
need to fetch from UniProt. For this we can use the
<strong>protti</strong> function <code>fetch_uniprot()</code>. In
addition to the protein sequence we will also need information about PDB
identifiers associated with the protein, which can also be accessed via
UniProt.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Input UniProt IDs</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>uniprot_ids <span class="ot">&lt;-</span> <span class="fu">unique</span>(ptsi_pgk<span class="sc">$</span>pg_protein_accessions)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Fetch UniProt information</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>uniprot_information <span class="ot">&lt;-</span> <span class="fu">fetch_uniprot</span>(<span class="at">uniprot_ids =</span> uniprot_ids,</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>                                     <span class="at">columns =</span> <span class="fu">c</span>(<span class="st">&quot;sequence&quot;</span>, <span class="st">&quot;xref_pdb&quot;</span>))</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Add UniProt information and find peptide positions</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>ptsi_pgk_annotated <span class="ot">&lt;-</span> ptsi_pgk <span class="sc">%&gt;%</span> </span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">left_join</span>(uniprot_information, <span class="at">by =</span> <span class="fu">c</span>(<span class="st">&quot;pg_protein_accessions&quot;</span> <span class="ot">=</span> <span class="st">&quot;accession&quot;</span>)) <span class="sc">%&gt;%</span> </span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">find_peptide</span>(<span class="at">protein_sequence =</span> sequence, <span class="at">peptide_sequence =</span> pep_stripped_sequence)</span></code></pre></div>
</div>
</div>
<div id="fetching-structural-information" class="section level1">
<h1>Fetching structural information</h1>
<p>You can access structural information with <strong>protti</strong> in
order to see if there are protein structures available for your protein,
how they were acquired and if they fit your quality requirements.</p>
<p>In the previous step we already retrieved information about the
availability of protein structures for your protein of interest using
the <code>fetch_uniprot()</code> function. The column
<code>xref_pdb</code> contains PDB identifiers if there is a structure
available. Since the identifiers are pasted together into one string we
need to separate them into individual identifiers to provide them to the
<code>fetch_pdb()</code> function. This can be achieved through a
combination of the <code>stringr</code> function
<code>str_split()</code> and the <code>tidyr</code> function
<code>unnest()</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract PDB IDs from UniProt information</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>ptsi_pgk_pdb_ids <span class="ot">&lt;-</span> ptsi_pgk_annotated <span class="sc">%&gt;%</span> </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">distinct</span>(pg_protein_accessions, xref_pdb) <span class="sc">%&gt;%</span> </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">pdb_id =</span> <span class="fu">str_split</span>(xref_pdb, <span class="at">pattern =</span> <span class="st">&quot;;&quot;</span>)) <span class="sc">%&gt;%</span> </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">unnest</span>(pdb_id) <span class="sc">%&gt;%</span> </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(pdb_id <span class="sc">!=</span> <span class="st">&quot;&quot;</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Fetch pdb information</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>ptsi_pgk_pdb_information <span class="ot">&lt;-</span> <span class="fu">fetch_pdb</span>(<span class="at">pdb_ids =</span> <span class="fu">unique</span>(ptsi_pgk_pdb_ids<span class="sc">$</span>pdb_id))</span></code></pre></div>
<p>The result of <code>fetch_pdb()</code> contains a multitude of
information. These include for example the experimental method that was
used to determine the structure (<code>experimental_method</code> and
<code>structure_method</code>). Depending on the method, there are
columns specific to them. For example the column
<code>ph_crystallisation</code> contains information about the pH of the
solution used for crystallisation if X-ray crystallography was used as a
method, while the column <code>ph_nmr</code> contains equivalent
information if the method was NMR. A structure resolution
(<code>resolution_combined</code>) is for example only included if
available, which is not the case for NMR structures.</p>
<p>Generally, the molecular information about the structure is divided
into “polymer” and “nonpolymer”. While nonpolymer information concerns
binding partners such as metal-ions, metabolites, drugs or other small
molecules, the polymer information concerns the protein or
polynucleotide.</p>
<p>You could for example only consider structures for your analysis that
were determined by X-ray crystallography and that have a resolution of
below 3 Å. In addition, you could select only the one structure that
contains the longest sequence stretch for each of our proteins (the
structure with the maximum <code>length</code>). This can be achieved in
the following way:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>filtered_structures <span class="ot">&lt;-</span> ptsi_pgk_pdb_information <span class="sc">%&gt;%</span> </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(experimental_method <span class="sc">==</span> <span class="st">&quot;X-ray&quot;</span>,</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>         resolution_combined <span class="sc">&lt;=</span> <span class="dv">3</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(reference_database_accession) <span class="sc">%&gt;%</span> </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(length <span class="sc">==</span> <span class="fu">max</span>(length)) <span class="sc">%&gt;%</span> </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ungroup</span>()</span></code></pre></div>
<p>Generally, you can use the information retrieved by
<code>fetch_pdb()</code> in any way that fits your specific research
question. However, you should note that by using very strict filtering
criteria you might remove some of the proteins that actually have
structural information. This could be because their structures do not
have a high enough resolution or they are not solved using the method of
your choice. Filtering by length should also be done with care since for
some proteins there might not be any full length structure but two
structures of different domains that would make up the whole structural
information if used in combination.</p>
<div id="fetching-atomic-structural-information" class="section level2">
<h2>Fetching atomic structural information</h2>
<p>In addition to the general structural information that can be
retrieved with <code>fetch_pdb()</code> you can also access atom level
information for each structure using the
<code>fetch_pdb_structure()</code> function. This information is mainly
useful for applications that rely on the coordinates of each atom in the
structure. Later in this vignette we will demonstrate how this can be
used in the <code>create_structure_contact_map()</code> function.
Furthermore, <code>fetch_pdb_structure()</code> retrieves B-factors for
each atom.</p>
<p>Similar to <code>fetch_pdb()</code> PDB identifiers are provided as
input to <code>fetch_pdb_structure()</code>. In the example below we
provide the two PDB IDs that were left after the filtering from the
previous step was applied to the data. If not too many structures
(~&lt;20) are fetched at once it is possible to combine all information
in a data frame by setting the <code>return_data_frame</code> argument
to <code>TRUE</code>. This is by default <code>FALSE</code>, which will
return a list instead with each element representing one structure.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Input PDB IDs</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>pdb_ids <span class="ot">&lt;-</span> <span class="fu">unique</span>(filtered_structures<span class="sc">$</span>pdb_ids) <span class="co"># &quot;1ZMR&quot;, &quot;2HWG&quot;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Fetch atom level structural information</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>ptsi_pgk_structure_information <span class="ot">&lt;-</span> <span class="fu">fetch_pdb_structure</span>(<span class="at">pdb_ids =</span> pdb_ids,</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>                                                      <span class="at">return_data_frame =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
</div>
<div id="fetching-atomic-structure-prediction-information-from-alphafold" class="section level2">
<h2>Fetching atomic structure prediction information from AlphaFold</h2>
<p>If a protein does not have any available structure you can
alternatively fetch protein structure predictions from <a href="https://www.nature.com/articles/s41586-021-03819-2">AlphaFold</a>
using the <code>fetch_alphafold_prediction()</code> function. The
function works similar to <code>fetch_pdb_structure()</code> but it
takes UniProt identifiers instead of PDB identifiers as input.
Furthermore, there is the option to fetch all predictions for an
organism as a whole. The B-factor information in AlphaFold predictions
represents the quality score of the atom position prediction.</p>
<p>It is of course also possible to retrieve structure prediction
information for proteins that have a known protein structure. In the
example below we will retrieve prediction information for our two
proteins ptsi (P08839) and pgk (P0A799). The output column
<code>score_quality</code> annotates the score from the
<code>prediction_score</code> column based on the official AlphaFold
score quality annotations and cutoffs.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Fetch atom level structural prediction information from AlphaFold</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>ptsi_pgk_prediction_information <span class="ot">&lt;-</span> <span class="fu">fetch_alphafold_prediction</span>(<span class="at">uniprot_ids =</span> uniprot_ids,</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                                                              <span class="at">return_data_frame =</span> <span class="cn">TRUE</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Example for fetching all predictions for Methanocaldococcus jannaschii</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co"># mj_predictions &lt;- fetch_alphafold_prediction(organism_name = &quot;Methanocaldococcus jannaschii&quot;)</span></span></code></pre></div>
</div>
<div id="alphafold-domain-predictions-using-the-predicted-aligned-error-pae" class="section level2">
<h2>AlphaFold domain predictions using the predicted aligned error
(PAE)</h2>
<p>AlphaFold predictions come with two kinds of error metrics, the
per-residue confidence score (pLDDT) that is saved in the b-factor
information of structure files and the predicted aligned error (PAE)
that can be downloaded separately from the EBI database. According to
the description on the EBI website, the PAE matrix at position (x, y)
indicates AlphaFold’s expected position error at residue x, when the
predicted and true structures are aligned on residue y. This is useful
for assessing inter-domain accuracy. One interesting use case for the
PAE is the prediction of domains in AlphaFold predictions. Tristan Croll
created a <a href="https://github.com/tristanic/pae_to_domains">python
script</a> that uses a graph-based community clustering algorithm on
PAEs in order to infer pseudo-rigid protein domains. These domain
predictions can be for example used in order to check the validity of
distance calculations between residues of a predicted structure. If
residues are on two different domains distances should be used with
caution.</p>
<p>With <strong>protti</strong> we provide the function
<code>fetch_alphafold_aligned_error()</code> that allows you to retrieve
the predicted aligned error for AlphaFold predictions directly into your
R session. In addition, we adapted the python function from Tristan and
created the <strong>protti</strong> function
<code>predict_alphafold_domain()</code> that predicts protein domains
for AlphaFold predictions. In the example below we will retrieve PAEs
for our two proteins ptsi (P08839) and pgk (P0A799) and subsequently
predict protein domains. The <code>error_cutoff</code> argument of the
<code>fetch_alphafold_aligned_error()</code> function defines the
maximum error that should be saved. All higher values will be discarded
in order to reduce the size of the returned <code>list</code>. For the
<code>predict_alphafold_domain()</code> function we try out two
different <code>graph_resolution</code> values which will determine the
size of the clusters and thus how strict domains are created.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Fetch aligned errors</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>aligned_error <span class="ot">&lt;-</span> <span class="fu">fetch_alphafold_aligned_error</span>(<span class="at">uniprot_ids =</span> uniprot_ids,</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                                               <span class="at">error_cutoff =</span> <span class="dv">4</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Predict protein domains with graph_resolution of 1</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>af_domains_res_1 <span class="ot">&lt;-</span> <span class="fu">predict_alphafold_domain</span>(<span class="at">pae_list =</span> aligned_error,</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>                                       <span class="at">return_data_frame =</span> <span class="cn">TRUE</span>,</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>                                       <span class="at">graph_resolution =</span> <span class="dv">1</span>) <span class="co"># Default </span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Predict protein domains with graph_resolution of 0.5</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>af_domains_res_05 <span class="ot">&lt;-</span> <span class="fu">predict_alphafold_domain</span>(<span class="at">pae_list =</span> aligned_error,</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>                                       <span class="at">return_data_frame =</span> <span class="cn">TRUE</span>,</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>                                       <span class="at">graph_resolution =</span> <span class="fl">0.5</span>)</span></code></pre></div>
<div id="ptsi-domain-prediction-with-graph_resolution-1" class="section level4">
<h4>ptsI domain prediction with <code>graph_resolution = 1</code></h4>
</div>
<div id="ptsi-domain-prediction-with-graph_resolution-0.5" class="section level4">
<h4>ptsI domain prediction with <code>graph_resolution = 0.5</code></h4>
</div>
</div>
</div>
<div id="generation-of-structural-contact-maps" class="section level1">
<h1>Generation of structural contact maps</h1>
<p>A very useful structural analysis function provided by
<strong>protti</strong> is <code>create_structure_contact_map()</code>,
which uses atom level structural information to calculate distances
between atoms or amino acid residues. The generated contact map can be
used in order to visually assess which regions are in close proximity to
each other. Furthermore, you can use this function to identify all atoms
that are in a certain proximity to a ligand or other small molecules.
Additionally, protein-protein interfaces can be easily identified in
structures that contain protein complexes.</p>
<p>As mentioned in the introduction it is important to find start and
end positions of e.g. peptides in a specific structure file based on the
UniProt positions. How UniProt and structure positions relate to each
other can be extracted from data fetched through
<code>fetch_pdb()</code>. We provide the convenient
<code>find_peptide_in_structure()</code> function to actually perform
the conversion of UniProt positions to structure specific positions. It
either internally uses <code>fetch_pdb()</code> to obtain the necessary
information or it takes the previously fetched output from
<code>fetch_pdb()</code> as an input to its <code>pdb_data</code>
argument. In the latter case it is then also possible to first filter
the data to only perform the mapping on relevant structures, which will
also speed up the process.</p>
<p><em>Note: If AlphaFold predictions are used for the contact map this
step can be skipped and UniProt positions can be used directly since the
AlphaFold prediction numbering is based on the UniProt
positions.</em></p>
<p>In the following we are going to identify structure specific peptide
start and end positions for our annotated example data
(<code>ptsi_pgk_annotated</code>). By providing the previously created
<code>filtered_structures</code> data frame as the input to the
<code>pdb_data</code> argument, we will only determine the positions of
our peptides with regards to the structures contained in the filtered
data.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>ptsi_pgk_peptide_structure_positions <span class="ot">&lt;-</span> <span class="fu">find_peptide_in_structure</span>(</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>   <span class="at">peptide_data =</span> ptsi_pgk_annotated,</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>   <span class="at">peptide =</span> pep_stripped_sequence,</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>   <span class="at">start =</span> start,</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>   <span class="at">end =</span> end,</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>   <span class="at">uniprot_id =</span> pg_protein_accessions,</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>   <span class="at">pdb_data =</span> filtered_structures,</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>   <span class="at">retain_columns =</span> <span class="fu">c</span>(eg_precursor_id, diff, adj_pval))</span></code></pre></div>
<p><em>Note: The <code>peptide</code> argument in this function does not
necessarily require the peptide sequence but can also take any other
unique peptide identifier as input. This is possible because peptides
are not matched to the structure sequence by their sequence but are
identified based on their start and end positions in the
protein.</em></p>
<p>Before we calculate the structure contact map we are going to filter
our input data to only contain significant peptides. Those are the
peptides that meet our cutoff criteria for the fold change (log2(2)) and
adjusted p-values (0.01). The contact map will give us an insight into
regions that are in close proximity to our significant peptides. In this
way we will be able to assess whether significant peptides are in close
proximity to each other.</p>
<p>As mentioned previously, there are multiple conventions for positions
in structure files. For the <code>create_structure_contact_map()</code>
function it is important to provide the author defined positions and
chain names which are marked with the <code>auth</code> prefix. The
<code>distance_cutoff</code> argument is set to 10 Angstrom and will
only keep distances below that value, which will reduce the size of our
output. Since contact maps can easily reach a size of several hundred
megabytes (per map!) it is advisable to only keep the information
strictly required. Another argument that is by default set to
<code>TRUE</code> is <code>return_min_residue_distance</code>. This will
return a contact map that contains minimal residue distances instead of
atom distances, based on which the map is calculated initially.</p>
<p>By default contact maps are always created for the provided selection
with regards to the whole structure. If you provide an additional data
frame to the <code>data2</code> argument it is possible to compare your
selection provided to the <code>data</code> argument to this other
subsection. This will reduce the size of contact maps if only a subset
of distances should be calculated.</p>
<p><em>Note: You can also create contact maps for AlphaFold predictions.
In that case you can provide the UniProt ID to the <code>id</code>
argument.</em></p>
<p><em>Note: If you want to create a contact map of an unpublished or
simply downloaded structure that you have the .pdb or .cif file of, you
can provide the path to that structure to the
<code>structure_file</code> argument. In this case the <code>id</code>
argument should contain a column that only has the content
“my_structure”.</em></p>
<p><em>Note: The input to the
<code>create_structure_contact_map()</code> function can be a data frame
containing specific regions (e.g. significant peptides) of a structure
that you want to create the contact map for (as explained above and
demonstrated below). It is however also possible to create contact maps
for certain chains of the structure. In that case you only need to
provide the structure ID and chain ID. Furthermore, it is possible to
generate a complete contact map of each residue in the structure. In
that case you will only need to provide the structure ID. Each of these
options will increase the size of your map and also the time it takes to
create it. Therefore, you should use these options with
caution.</em></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter data for significant peptides.</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>significant_peptides <span class="ot">&lt;-</span> ptsi_pgk_peptide_structure_positions <span class="sc">%&gt;%</span> </span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="fu">abs</span>(diff) <span class="sc">&gt;</span> <span class="dv">2</span>, adj_pval <span class="sc">&lt;=</span> <span class="fl">0.01</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a structure contact maps </span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>contact_map <span class="ot">&lt;-</span> <span class="fu">create_structure_contact_map</span>(</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> significant_peptides,</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">id =</span> pdb_ids,</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">chain =</span> auth_asym_id,</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  <span class="at">auth_seq_id =</span> auth_seq_id,</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>  <span class="at">distance_cutoff =</span> <span class="dv">10</span>,</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>  <span class="at">pdb_model_number_selection =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>),</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>  <span class="at">return_min_residue_distance =</span> <span class="cn">TRUE</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span class="co"># This is a helper function for the plot.</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="co"># It allows the display of integers on the axis.</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>integer_breaks <span class="ot">&lt;-</span> <span class="cf">function</span>(<span class="at">n =</span> <span class="dv">5</span>, ...) {</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>  fxn <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    breaks <span class="ot">&lt;-</span> <span class="fu">floor</span>(<span class="fu">pretty</span>(x, n, ...))</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    <span class="fu">names</span>(breaks) <span class="ot">&lt;-</span> <span class="fu">attr</span>(breaks, <span class="st">&quot;labels&quot;</span>)</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    breaks</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(fxn)</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot structure contact maps</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a><span class="co"># 1ZMR</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>contact_map[[<span class="st">&quot;1ZMR&quot;</span>]] <span class="sc">%&gt;%</span> <span class="co"># Extract data frame from list</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">chain_combinations =</span> <span class="fu">paste0</span>(<span class="st">&quot;chain_&quot;</span>, label_asym_id_var1, <span class="st">&quot;_vs_chain_&quot;</span>, label_asym_id_var2)) <span class="sc">%&gt;%</span> </span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> label_seq_id_var1, <span class="at">y =</span> label_seq_id_var2, <span class="at">fill =</span> min_distance_residue)) <span class="sc">+</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_tile</span>() <span class="sc">+</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_y_continuous</span>(<span class="at">breaks =</span> <span class="fu">integer_breaks</span>()) <span class="sc">+</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_x_continuous</span>(<span class="at">breaks =</span> <span class="fu">integer_breaks</span>()) <span class="sc">+</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span>chain_combinations, <span class="at">scale =</span> <span class="st">&quot;free&quot;</span>) <span class="sc">+</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">&quot;Structure contact map 1ZMR&quot;</span>) <span class="sc">+</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a><span class="co"># 2HWG</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>contact_map[[<span class="st">&quot;2HWG&quot;</span>]] <span class="sc">%&gt;%</span> <span class="co"># Extract data frame from list</span></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">chain_combinations =</span> <span class="fu">paste0</span>(<span class="st">&quot;chain_&quot;</span>, label_asym_id_var1, <span class="st">&quot;_vs_chain_&quot;</span>, label_asym_id_var2)) <span class="sc">%&gt;%</span> </span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> label_seq_id_var1, <span class="at">y =</span> label_seq_id_var2, <span class="at">fill =</span> min_distance_residue)) <span class="sc">+</span></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_tile</span>() <span class="sc">+</span></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_y_continuous</span>(<span class="at">breaks =</span> <span class="fu">integer_breaks</span>()) <span class="sc">+</span></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_x_continuous</span>(<span class="at">breaks =</span> <span class="fu">integer_breaks</span>()) <span class="sc">+</span></span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">&quot;Structure contact map 2HWG&quot;</span>) <span class="sc">+</span></span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span>chain_combinations, <span class="at">scale =</span> <span class="st">&quot;free&quot;</span>) <span class="sc">+</span></span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code></pre></div>
<p>The contact map for each structure provided as input will be saved as
a separate element of a list, which is returned as the output of the
<code>create_structure_contact_map()</code> function. These elements can
be easily accessed using two square brackets (<code>[[]]</code>) right
behind the name of the list. The brackets should either contain the name
of the element or the index. You can also access each element in the
list in a loop using the <code>map()</code> function from the
<code>purrr</code> package.</p>
<p>Contact maps can be plotted using the <code>ggplot2</code> package if
they are not too large. Contact maps are based on positions of atoms or
residues in the structure. While atom IDs are unique, residues are only
unique within a certain chain. That means residue position 1 is likely
present in each of the chains. To correctly display contact map plots
for residues they should be faceted by the unique combinations of
chains. If e.g. the x-axis displays residues from chain A and the y-axis
residues of chain B this should be displayed in one specific facet.</p>
<p><em>Note: For the plot we recommend using the data base defined chain
and residue identifiers in contrast to the author defined ones that were
used as input to the <code>create_structure_contact_map()</code>
function. The reason is that in the data base definitions each molecular
entity has their own chain. If a certain protein is for example
associated with a metal ion, these might be stored in the same chain in
the author defined identifiers but separated into different chains for
the data base identifiers. The problem is that in the author defined
identifiers the residue numbers might not be consecutive and there could
be a large gap in the numbering between the protein and the metal
residue.</em></p>
<p>The two contact maps that were generated based on significant
peptides reveal some interesting information about the positioning of
the peptides.</p>
<p>The “1ZMR” structure contains only one protein chain (A). In the
contact map of significant peptides that are all located in chain A in
relation to all other residues in chain A we can see that even though
some of the peptides are quite far apart in the sequence, some are
within 10 Angstrom distance in 3D space. Chain B and chain D are a
calcium atom, respectively. In case of chain B the atom is actually in
close proximity to one of the significant peptides. Chain E stores
information about water molecules in the structure. The contact map is
not very informative in this case, since the y-axis residue does not
indicate any specific relationship of the water molecules with each
other. Here it would be interesting to look at the distances of the
water molecules to the peptide. If there are no water molecules in close
proximity, this might indicate that the peptide is not surface
exposed.</p>
<p>The “2HWG” structure contains two protein chains (A and B). Within
each protein the significant peptides seem to be in close proximitiy to
each other. In this case we can also observe that the peptide located
around residue 555 is in close proximity to the other protein chain,
which indicates that it might be located within a protein-protein
interaction interface. Chain C and E contain a magnesium ion that seems
to be in the proximity of two peptides. Chain D and F contain an oxalate
ion which is known to inhibit ptsI. The oxalate ion is in very close
proximity to to the same peptide that is close to the magnesium ion.
This is likely the case because the oxalate ion and magnesium ion are
located in the same site. Chain H and G contain water molecules.</p>
</div>
<div id="mapping-of-amino-acids-peptides-or-regions-on-3d-protein-structures-and-predictions" class="section level1">
<h1>Mapping of amino acids, peptides or regions on 3D protein structures
and predictions</h1>
<p>Contact maps provide quantitative information about the distances of
residues to each other. We can use them to perform further high
throughput analysis. In contrast to the rather complex contact map plots
it is easier to look at the actual protein structures and the respective
peptide positions to get a better overview of the proximity of peptides
to each other and in relation to interesting sites. While this analysis
is more subjective, it can make certain relationships in the data more
obvious.</p>
<p>For the mapping of peptides, protein regions or amino acids on PDB
structures or AlphaFold predictions, we provide the
<code>map_peptide_on_structure()</code> function. Mapping is
accomplished based on the replacement of B-factor information in the
structure file with peptide specific values. When the structure is
coloured by B-factor in PyMOL or ChimeraX, peptides will get
highlighted. This function can on the one hand just display categorical
information such as if the peptide is significant, present or
undetected. On the other hand, continuous information can be displayed
such as a score associated with each individual amino acid.</p>
<p>The mapping is performed based on positions and not peptide sequence
matching. If you want to perform the mapping onto a PDB structure, you
should run the <code>find_peptide_in_structure()</code> beforehand to
obtain structure specific positions. If you want to map onto an
AlphaFold prediction it is not necessary to carry out this step.
However, the output of the <code>find_peptide_in_structure()</code>
function will contain all necessary information to perform also
AlphaFold predictions in case there is no available structure file.</p>
<p>For this function it is important to provide the author defined
positions and chain names which are marked with the <code>auth</code>
prefix. The function performs structural mapping based on this naming
convention.</p>
<p><em>Note: If you perform mapping onto an AlphaFold prediction the
content of the <code>pdb_id</code> provided column should be
NA.</em></p>
<p><em>Note: If you want to map peptides to an unpublished or downloaded
structure that you have the .pdb or .cif file of, you can provide the
path to that structure to the <code>structure_file</code> argument. In
this case you do not need to provide the <code>pdb_id</code> argument.
It is very important that your input data frame
<code>peptide_data</code> only contains information for the protein in
the provided structure file and not for other unrelated proteins,
otherwise mapping is not performed correctly.</em></p>
<p>You provide information on colouring through the
<code>map_value</code> argument. This should contain a numeric column.
In the example below we insert the number 100 into this column if a
peptide is significantly changing based on our previous cutoff criteria
and the value 0 if it is not but was detected in the experiment. In this
case you could simply insert any two numbers. However, the first number
that colours your positive hits should be higher. The function will
internally scale these values between 50 and 100. In this case 0 would
become 50 and 100 stays 100. All regions of the structure that were not
covered by any of you peptides receive the final value 0. This allows us
to distinguish between covered (50-100) and non-covered (0) regions as
well as covered non-significant (50) and significant regions (100). This
is especially helpful if peptides are coloured according to a continuous
score (see later in this vignette).</p>
<p>Lastly, we can specify an export location to indicate a place where
the structure file should be saved. In this example the location is
specified as a temporary file directory using the <code>tempdir()</code>
function. You should change that location to any more accessible place.
If you leave the argument empty, structures will be automatically saved
in your working directory.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>ptsi_pgk_peptide_structure_positions <span class="sc">%&gt;%</span> </span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">map_value =</span> <span class="fu">ifelse</span>(eg_precursor_id <span class="sc">%in%</span> significant_peptides<span class="sc">$</span>eg_precursor_id, </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>                            <span class="dv">100</span>, </span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>                            <span class="dv">0</span>)) <span class="sc">%&gt;%</span> </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map_peptides_on_structure</span>(</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>   <span class="at">uniprot_id =</span> pg_protein_accessions,</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>   <span class="at">pdb_id =</span> pdb_ids,</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>   <span class="at">chain =</span> auth_asym_id,</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>   <span class="at">auth_seq_id =</span> auth_seq_id,</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>   <span class="at">map_value =</span> map_value,</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>   <span class="at">file_format =</span> <span class="st">&quot;.pdb&quot;</span>, </span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>   <span class="at">export_location =</span> <span class="fu">tempdir</span>() <span class="co"># change to a location of your choice</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a> )</span></code></pre></div>
<p>The function does not return anything in the R environment.
Structures are directly saved in the desired format. The files contain
the name of the structure and separated by “_” the name of all UniProt
IDs present in the structure file.</p>
<p>To visualise coloured regions in your proteins you should open the
file in either PyMOL or ChimeraX. There you have the option to colour
structures by B-factor. Alternatively, we present an option within R
using the <code>r3dmol</code> package to interactively display
structures with the help of htmlwidgets.</p>
<div id="d-structure-mapping-in-r-using-r3dmol" class="section level3">
<h3>3D structure mapping in R using r3dmol</h3>
<p>It is possible to use the <a href="https://swsoyee.github.io/r3dmol/index.html"><code>r3dmol</code></a>
package to visualize protein structures directly in R. The package is
still under development and provides support for <a href="https://3dmol.csb.pitt.edu/index.html"><code>3Dmol.js</code></a>.
You can find extensive documentation and examples on their GitHub page.
Below we provide a specific example of how to use the package in order
to visualise structures created by
<code>map_peptides_on_structure()</code> in R colouring by B-factors.
Later we provide an example of how to use a colour gradient. In fact the
same function that is used later can also be used in this case.</p>
<p>If you run the code snippets on your own make sure you replace
<code>paste0(tempdir(), &quot;/1ZMR_P0A799.pdb&quot;)</code> with the location and
file you want to visualise.</p>
<p><code>r3dmol</code> facilitates direct interaction with the structure
if this vignette is exported as an html document. You can for example
zoom, rotate or move the structure.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Install the r3dmol package if it is not installed</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co"># install.packages(&quot;r3dmol&quot;)</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Load the r3dmol package</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(r3dmol) </span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Create structure</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="fu">r3dmol</span>() <span class="sc">%&gt;%</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">m_add_model</span>(<span class="at">data =</span> <span class="fu">paste0</span>(<span class="fu">tempdir</span>(), <span class="st">&quot;/1ZMR_P0A799.pdb&quot;</span>), <span class="at">format =</span> <span class="st">&quot;pdb&quot;</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">m_set_style</span>(<span class="at">style =</span> <span class="fu">m_style_cartoon</span>(</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">colorfunc =</span> <span class="st">&quot;</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="st">        function(atom) {</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="st">          if (atom.b == 50) {return &#39;#90EE90&#39;};</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="st">          if (atom.b == 100) {return &#39;#FF7276&#39;};</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="st">          if (atom.b == 0) {return &#39;white&#39;};</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="st">          return &#39;white&#39;;</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="st">        }&quot;</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>  )) <span class="sc">%&gt;%</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">m_zoom_to</span>()</span></code></pre></div>
</div>
<div id="pymol" class="section level3">
<h3>PyMOL</h3>
<p>The following command colours structures by B-factor. You can specify
a gradient with predefined or custom colours separating them by
underscores. The gradient can also contain more than 3 different colour
steps. The minimum and maximum values of the gradient should also be
specified. These are based on the previously mentioned scaling. In the
below gradient all non-covered regions will be gray. Covered by
non-significant regions will be “palegreen” and signficiant regions will
be “deepsalmon”.</p>
<pre><code>spectrum b, gray70_palegreen_deepsalmon, minimum = 0, maximum = 100</code></pre>
<p>Custom colours can be defined with the following command and
subsequently used in the command above.</p>
<p><em>Note: Custom names should not contain underscores since this
confuses PyMOL when the gradient function is used.</em></p>
<pre><code>set_color cpink, [235, 52, 189]
set_color cblue, [52, 171, 235]</code></pre>
</div>
<div id="chimerax" class="section level3">
<h3>ChimeraX</h3>
<p>In Chimera you have similar options like in PyMOL for colouring
structures by B-factors. You can use the command below to create a
colour gradient over the structure.</p>
<pre><code>color bfactor palette darkgrey:darkseagreen:salmon</code></pre>
<p>If you only want to colour proteins by B-factors while leaving other
entities such as nucleic acids or small molecules in their default
colour you can use the following command instead.</p>
<pre><code>color byattribute bfactor protein palette darkgrey:darkseagreen:salmon</code></pre>
</div>
<div id="result" class="section level2">
<h2>Result</h2>
<p>The figures below are the results of performing the colouring steps
on the two structures of ptsI and pgk with significantly changing
peptides highlighted in red. Areas in gray were not covered by any
detected peptides.</p>
<p>For ptsI which was treated with fructose 1,6-bisphosphatase (FBP) the
significantly changing peptides are all located in the same region of
the protein. They are in close proximity to the active site that
contains the magnesium atom coloured in blue and the oxalate ion
coloured in purple. The contact maps showed a significant peptide in
close proximity to the protein-protein interaction surface of the
homodimer. This peptide is indicated by black arrows. It is not buried
in the binding site but rather located at the edge of it. Its residues
are, however, directly participating in the formation of the interaction
surface through hydrogen bonds and likely a pi-pi stacking between a
proline and histidine residue. The fact that there are no significant
peptides buried in the interaction surface likely indicates that the
complex does not dissociate into its subunits upon FBP treatment. It is
more likely that FBP treatment induces a general structural change
observable in the vicinity of the active site due to its likely binding
to this site. This observation is also in line with the fact that FBP is
an inhibitor of ptsI (<a href="https://pubmed.ncbi.nlm.nih.gov/33357446/">Cappelletti
2021</a>).</p>
<p>Mapping of significantly changing peptides onto the pgk structure
reveals that most of the protein seems to be structurally affected by
the treatment with 3-phosphoglyceric acid (3PG). Based on UniProt
annotations and the similarity of the protein to its homologues in other
organisms, the 3PG binding site is located on the left side indicated
with a black arrow. None of the residues involved in the interaction
with 3PG are found in a significantly changing peptide. Due to the
compact size of the protein and the even distribution of significant
peptides it is hard to draw any conclusions about potential structural
effects of the treatment.</p>
</div>
<div id="mapping-of-amino-acid-scores" class="section level2">
<h2>Mapping of amino acid scores</h2>
<p>In order to narrow down and prioritize structurally affected protein
regions, we have developed the amino acid scoring function
<code>calculate_aa_scores()</code>. For each amino acid position in the
protein the function calculates the average product of the
-log10(adjusted p-value) and the absolute log2(fold change) per peptide,
covering the amino acid position. In other words, the information of all
the peptides in a specific region is integrated, which strengthens the
confidence of a structural change being true since false positive
peptides are averaged out. One downside of this approach is that it
relies on very good sequence coverage since otherwise false positive
peptides with high scores that solely cover a specific region are not
distinguishable from real hits. In our example we are lucky that both
proteins have a very high coverage.</p>
<p>To map the amino acid scores, the amino acid positions within the
protein structure need to be correctly assigned first using
<code>find_peptide_in_structure()</code>, with the <code>residue</code>
column as input for <code>peptide</code>, the <code>start</code> and the
<code>end</code> position. This step is required after the amino acid
score calculation, since <code>calculate_aa_score()</code> needs a
numeric input for start and end positions, and therefore,
<code>auth_seq_id</code> (a character column) cannot be used as an
input.</p>
<p>The <code>map_peptides_on_structure()</code> function is capable of
mapping continuous values to a structure. In this case values are again
scaled between 50 and 100. It is likely that values fall in between 50
and 100 which is displayed as a colour gradient step in between the
colour in the middle of the gradient (50) and the colour at the end of
the gradient (100).</p>
<p><strong>Important: If you run this Vignette locally, make sure to
save the structures generated next in a different folder than the
previous ones. Otherwise the last structures will be
overwritten.</strong></p>
<p><em>Note: If multiple structures are mapped at the same time, by
default each structure scales its map values between 50 and 100 based on
its minimum and maximum score. It is also possible to use one scale for
all structures that are mapped if the <code>scale_per_structure</code>
argument of the <code>map_peptides_on_structure()</code> function is set
to <code>FALSE</code>. In this case only one of the structures (the one
containing the highest score) will have the 100 value. The highest score
of the other structures will be lower than 100. This means that the
scale of colours between both structures is comparable.</em></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the amino acid score</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>amino_acid_score <span class="ot">&lt;-</span> <span class="fu">calculate_aa_scores</span>(</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> ptsi_pgk_peptide_structure_positions,</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">protein =</span> pg_protein_accessions,</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">diff =</span> diff,</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">adj_pval =</span> adj_pval,</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">start_position =</span> start,</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">end_position =</span> end,</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">retain_columns =</span> <span class="fu">c</span>(pdb_ids, auth_asym_id)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Find amino acid positions in the structure</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>ptsi_pgk_amino_acid_structure_positions <span class="ot">&lt;-</span> <span class="fu">find_peptide_in_structure</span>(</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>   <span class="at">peptide_data =</span> amino_acid_score,</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>   <span class="at">peptide =</span> residue,</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>   <span class="at">start =</span> residue,</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>   <span class="at">end =</span> residue,</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>   <span class="at">uniprot_id =</span> pg_protein_accessions,</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>   <span class="at">pdb_data =</span> filtered_structures,</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>   <span class="at">retain_columns =</span> <span class="fu">c</span>(amino_acid_score))</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Map the score on structure</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a><span class="fu">map_peptides_on_structure</span>(</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>  <span class="at">peptide_data =</span> ptsi_pgk_amino_acid_structure_positions,</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>   <span class="at">uniprot_id =</span> pg_protein_accessions,</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>   <span class="at">pdb_id =</span> pdb_ids,</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>   <span class="at">chain =</span> auth_asym_id,</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>   <span class="at">auth_seq_id =</span> auth_seq_id,</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>   <span class="at">map_value =</span> amino_acid_score,</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>   <span class="at">file_format =</span> <span class="st">&quot;.pdb&quot;</span>,</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>   <span class="at">export_location =</span> <span class="fu">tempdir</span>()</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a> )</span></code></pre></div>
<p>While the previous method of displaying only significantly changing
peptides that have a minimum fold change is useful for the
identification of regions that change the most, it is not resistant to
false positive peptides. The score on the other hand will only be high
if an amino acid is consistently part of significant and differentially
abundant peptides. The problem of the score is that it is hard and
visually even impossible to interpret what a certain score means. This
is due to the fact that the same score can be caused by two completely
different scenarios. On the one hand an amino acid might be associated
with peptides that have a low fold change but are highly significant. On
the other hand it can be associated with peptides that have a high fold
change but are of low significance. Both scenarios could yield the same
amino acid score. Therefore, the score should not be misinterpreted as
describing the extent of the change but should rather be seen as a
probability that a certain amino acid is really structurally
affected.</p>
<p>You can visualise the score as a colour gradient using the
<code>r3dmol</code> package in R. For that you need to first create a
gradient using the <code>colorRampPalette()</code> function, which
creates a function capable of creating a colour gradient over the
specified colours. Instead of providing only three colours to this
function you can provide additional colours to make a gradient with
multiple substeps. It is important to always use 101 colours to get the
full range for the structure. The colour gradient needs to be
concatenated using <code>paste0()</code> and provided to the
<code>colorfunc</code> argument within the shown javascript function
context.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create a color gradient with 101 colors</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>color_gradient <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">&#39;&quot;&#39;</span>, </span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>                         <span class="fu">paste</span>(<span class="fu">colorRampPalette</span>(<span class="fu">c</span>(<span class="st">&quot;white&quot;</span>, <span class="st">&quot;#90EE90&quot;</span>, <span class="st">&quot;#FF7276&quot;</span>))(<span class="dv">101</span>), </span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>                               <span class="at">collapse =</span> <span class="st">&#39;&quot;, &quot;&#39;</span>), </span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>                         <span class="st">&#39;&quot;&#39;</span>)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co"># create structure</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="fu">r3dmol</span>() <span class="sc">%&gt;%</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">m_add_model</span>(<span class="at">data =</span> <span class="fu">paste0</span>(<span class="fu">tempdir</span>(), <span class="st">&quot;/2HWG_P08839.pdb&quot;</span>), <span class="at">format =</span> <span class="st">&quot;pdb&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">m_set_style</span>(<span class="at">style =</span> <span class="fu">m_style_cartoon</span>(</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">colorfunc =</span> <span class="fu">paste0</span>(<span class="st">&quot;</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="st">        function(atom) {</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a><span class="st">          const color = [&quot;</span>, color_gradient,<span class="st">&quot;]</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="st">          return color[Math.round(atom.b)]</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a><span class="st">        }&quot;</span>)</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>  )) <span class="sc">%&gt;%</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">m_zoom_to</span>()</span></code></pre></div>
<p>Applying the score to both structures refines the region that is most
robustly affected by the treatment. For ptsI it seems that a region of
amino acids directly in the active center are consistently affected. In
addition we see a small region below, which was previously not seen due
to its low fold changes that did not meet the cutoff. The score tells us
that this region is indeed consistently affected and that there is
likely a structural change occurring even though the fold change of
peptides is rather low. The region in the binding interface previously
indicated with a black arrow is now not highlighted anymore, indicating
that this was likely a false positive hit and that other peptides in the
same region do not exhibit a strong and significant response.</p>
<p>For ptg we see that the most robustly changing region is very close
to the binding site of 3PG, which the protein was treated with. In this
case, the score helped to refine the binding site of the compound since
previously almost the whole protein was covered with significantly
changing peptides.</p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
